"""
Itertools module

* Python's Itertool is a module that provides various functions that work on
  iterators to produce complex iterators.
* This module works as a fast, memory-efficient tool that is used either by
  themselves or in combination to form iterator algebra
* Different types of iterators provided by this module are:
  * Infinite iterators
  * Combinatoric iterators
  * Terminating iterators
* Reference: https://docs.python.org/3/library/itertools.html
"""


###############################################################################
# Module Import
###############################################################################


# Importing the module
# * We can import this module using the `import` statement as follows
import itertools


###############################################################################
# Infinite Iterators
###############################################################################


# Count
# * Used to count numbers starting from the number mentioned in its arguments
#   and continues indefinitely
# * Syntax: count(start, step=1)
for n in itertools.count(5, 5):
    print(n)
    break  # Stop the loop otherwise it will run indefinitely
# 5, 10, 15, 20, 25...


# Cycle
# *  Used to cycle over a collection of values infinitely
# * Syntax: cycle(iterable)
x = ['A', 'B', 'C']
for i in itertools.cycle(x):
    print(i)
    break  # Stop the loop otherwise it will run indefinitely
# A, B, C, A, B, C, A...


# Repeat
# * Used to repeat a value infinitely
# * If the optional keyword argument times is specified, it returns the
#   specified number of repetitions
# * Syntax: repeat(object, times=None)
x = itertools.repeat(1, 3)
y = list(x)
print(y)
# [1, 1, 1]


###############################################################################
# Combinatoric Iterators
###############################################################################


# Product
# * This tool computes the cartesian product of input iterables. To compute the
#   product of an iterable with itself, we use the optional repeat keyword
#   argument to specify the number of repetitions.
# * The output of this function are tuples in sorted order
# * Syntax: product(*iterables, repeat=1)
x = itertools.product([1, 2], ['A', 'B'])
print(list(x))
# [(1, 'A'), (1, 'B'), (2, 'A'), (2, 'B')]


# Permutations
# * Is used to generate all possible permutations of an iterable. All elements
#   are treated as unique based on their position and not their values
# * This function takes an iterable and group_size, if the value of group_size
#   is not specified or is equal to None then the value of group_size becomes
#   length of the iterable
# * Syntax: permutations(iterable, r=None)
x = itertools.permutations([1, 2, 3])
print(list(x))
# [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]


# Combinations
# * This iterator prints all the possible combinations(without replacement) of
#   the container passed in arguments in the specified group size in sorted
#   order
# * Syntax: combinations(iterable, r)
x = itertools.combinations([1, 2, 3], 2)
print(list(x))
# [(1, 2), (1, 3), (2, 3)]


# Combinations with replacement
# * This function returns a subsequence of length n from the elements of the
#   iterable where n is the argument that the function takes determining the
#   length of the subsequences generated by the function.
# * Individual elements may repeat itself in combinations_with_replacement
#   function
# * Syntax: combinations_with_replacement(iterable, r)
x = itertools.combinations_with_replacement([1, 2, 3], 2)
print(list(x))
# [(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)]


###############################################################################
# Terminating Iterators
###############################################################################


# Accumulate
# * This iterator takes two arguments, iterable target and the function which
#   would be followed at each iteration of value in target
# * If no function is passed, addition takes place by default
# * If the input iterable is empty, the output iterable will also be empty
# * Syntax: accumulate(iterable, func=None, *, initial=None)
x = itertools.accumulate([1, 2, 3], lambda x, y: x + y)
print(list(x))
# [1, 3, 6]


# Chain
# * This function is used to print all the values in iterable targets one after
#   another mentioned in its arguments
# * Syntax: chain(*iterables)
x1 = [1, 2, 3]
x2 = [4, 5, 6]
y = itertools.chain(x1, x2)
print(list(y))
# [1, 2, 3, 4, 5, 6]


# Chain (from iterable)
# * This function is implemented similarly as chain() but the argument here is
#   a list of lists or any other iterable container
# * Syntax: chain.from_iterable(iterable)
x = [[1, 2, 3], [4, 5, 6]]
y = itertools.chain.from_iterable(x)
print(list(y))
# [1, 2, 3, 4, 5, 6]


# Compress
# * This iterator selectively picks the values to print from the passed
#   container according to the boolean list value passed as other arguments
# * The arguments corresponding to boolean true are printed else all are
#   skipped
# * Syntax: compress(data, selectors)
x = itertools.compress('Hello World', [1, 0, 1, 0, 0, 1])
print(list(x))
# ['H', 'l', 'o']


# Takewhile
# * This iterator is opposite of dropwhile(), it prints the values till the
#   function returns false for 1st time
# * Syntax: takewhile(predicate, iterable)
x = itertools.takewhile(lambda x: x != ' ', 'Hello World')
print(list(x))
# ['H', 'e', 'l', 'l', 'o']


# Dropwhile
# * This iterator starts printing the characters only after the func. in
#   argument returns false for the first time
# * Syntax: dropwhile(predicate, iterable)
x = itertools.dropwhile(lambda x: x != ' ', 'Hello World')
print(list(x))
# [' ', 'W', 'o', 'r', 'l', 'd']


# Filterfalse
# * This iterator prints only values that return false for the passed function
# * Syntax: filterfalse(predicate, iterable)
x = itertools.filterfalse(lambda x: x == 1, [1, 2, 3])
print(list(x))
# [2, 3]


# Groupby
# * Make an iterator that returns consecutive keys and groups from the
#   iterable
# * The key is a function computing a key value for each element. If not
#   specified or is None, key defaults to an identity function and returns the
#   element unchanged
# NOTE: The iterable needs to be sort first!
# * Syntax: groupby(iterable, key=None)
x = [(1, 'A'), (1, 'B'), (2, 'A'), (2, 'B'), (3, 'A')]
y = itertools.groupby(x, lambda x: x[0])
for key, group in y:
    print(key, list(group))
# 1 [(1, 'A'), (1, 'B')]
# 2 [(2, 'A'), (2, 'B')]
# 3 [(3, 'A')]


# Islice
# * Make an iterator that returns selected elements from the iterable
# * Syntax: islice(iterable, stop)
# * Syntax: islice(iterable, start, stop [, step])
x = itertools.islice([1, 2, 3], 2)
print(list(x))
# [1, 2]


# Starmap
# * Make an iterator that computes the function using arguments obtained from
#   the iterable. Used instead of map() when argument parameters are already
#   grouped in tuples from a single iterable
# * Syntax: starmap(function, iterable)
x = itertools.starmap(lambda x, y: x + y, [(1, 2), (3, 4)])
print(list(x))
# [3, 7]


# Tee
# * This iterator splits the container into a number of iterators mentioned in
#   the argument
# * Syntax: tee(iterable, n=2)
x = itertools.tee([1, 2, 3])
for group in x:
    print(list(group))
# [1, 2, 3]
# [1, 2, 3]


# Zip Longest
# * This iterator prints the values of iterables alternatively in sequence. If
#   one of the iterables is printed fully, remaining values are filled by the
#   values assigned to fillvalue
# * Syntax: zip_longest(*iterables, fillvalue=None)
x1 = ['A', 'B', 'C']
x2 = [1, 2, 3, 4, 5]
y = itertools.zip_longest(x1, x2)
print(list(y))
# [('A', 1), ('B', 2), ('C', 3), (None, 4), (None, 5)]
